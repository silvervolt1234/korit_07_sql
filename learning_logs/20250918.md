# CUD
1. Database 생성
```sql
CREATE DATABASE 데이터베이스명

CREATE DATABASE kor_it;
```

2. 특정 DB의 사용
```sql
USE 데이터베이스명

USE kor_it
```

3. 테이블 생성
```sql
CREATE TABLE 테이블명(
  컬럼1, 속성1, 속성2, ....,
  컬럼2, 속성1, 속성2, ....,
);

CREATE TABLE students(student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, enrollmemt_date DATE NOT NULL);
```
현재까지 students / students2라는 두 테이블을 생성했고 students2는 email이라는 추가 컬럼이 있어서 students에 컬럼을 추가해야 한다

- 컬럼 추가 SQL문
```sql
ALTER TABLE 테이블명 ADD COLUMN 컬럼명 자료형 조건;

ALTER TABLE students ADD COLUMN students_email VARCHAR(100) NOT NULL;
```

- 컬럼 삭제 SQL문
```sql
ALTER TABLE 테이블명 DROP COLUMN 컬럼명;
ALTER TABLE students2 DROP COLUMN email
```
해당 컬럼의 모든 데이터가 영구 삭제되고 복구 불가능하기에 백업 등의 준비가 필요

- 컬럼 수정 SQL문
1. CHANGE : 기존 컬럼명 및 자료형과 조곤을 전부 새로 세팅할 때 사용
```sql
ALTER TABLE CHANGE COLUMN 기존컬럼명 새컬럼명 자료형, 조건

ALTER TABLE students2 CHANGE COLUMN email studnet2_email VARCHAR(100) NOT NULL;
```
CHANGE를 쓸 경우 컬럼만 바꿔도 자료형 조건 전부 명시

2. RENAME : 컬럼의 이름만 변경하고 기본 자료형과 조건은 유지. DB에 따라 지원이 되는것도 있고 아닌것도 존재
```sql
ALTER TABLE students2 RENAME COLUMN 기존컬럼명 TO 새컬럼명;

ALTER TABLE students2 RENAME COLUMN email TO students2_email;
```

enrollment_date를 삭제하고 다시 student_enrollment_date를 추가

students_id / students_name / students_email / students_enrollment_date
```sql
ALTER TABLE students DROP enrollment_date;  # 삭제
ALTER TABLE students ADD COLUMN students_enrollment_date VARCHAR(100) NOT NULL;   # 추가
```
DB 생성 / DB 사용 / 테이블 생성 / 컬럼 추가 / 컬럼 수정 / 컬럼 삭제와 관련된 DDL

- students 테이블에 데이터 삽입 SQL문
```sql
INSERT INTO 테이블명 (컬럼명1, 컬럼명2, ..., 컬럼명n) VALUES (데이터a1, 데이터a2, ... , 데이터an), (데이터b1, 데이터b2, ... , 데이터bn);

INSERT INTO students (students_name, students_email, students_enrollment_date) VALUES ('김일', 'kim1@test.com', '2025-09-18'), ('김이', 'kim2@test.com', '2025-01-01')
```
이상의 코드에서 주목할 점은 students_id 컬럼에 값을 넣지 않았는데 이유는 테이블 생성시(=DDL 사용시) AUTO INREMENT를 적용했기 때문

전체 컬럼에 차례로 데이터를 입력한다고 가정하면 (컬럼명1, 컬럼명2, ... 컬럼명N)이 없어도 되지만 실무에서는 명확하게 하기위해 항상 명시하는 편

- 특정 데이터 수정 SQL문
```sql
UPDATE 테이블명 SET 컬럼명 = 바꿀데이터값 WHERE 컬럼명 = 검색가능한데이터값

UPDATE students SET students_name = '김사백오십' WHERE students_id = 1;
```

- 특정 데이터 삭제 SQL문
```sql
DELETE FROM 테이블명 WHERE 조건
```

지시 사항

1. 김삼 / kim3@test.com / 2025-02-01 데이터를 추가
2. 김사 / kim4@test.com / 2025-03-01 데이터를 추가
3. 김삼 데이터를 삭제
4. 김사 이름을 가진 데이터의 students_enrollment_data를 2024-04-04fh tnwjd
5. select로 김사만 콘솔에 출력
```sql
INSERT INTO students (students_name, students_email, students_enrollment_date) VALUES ('김삼', 'kim3@test.com', '2025-03-01'), ('김사', 'kim4@test.com', '2025-04-01');

DELETE FROM students WHERE students_id = 3;


UPDATE students SET students_enrollment_date = '2024-04-04' WHERE students_id = 4;

SELECT * FROM students WHERE students_id = 4;
```

지시사항 - 다음을 만족하는 테이블을 생성
1. 테이블명 : instructor
2. 컬럼명:
  1) instructor_id / INT / PK / auto increment 
  2) name / varchar(100) / not null
  3) eamil / varchar(100) / not null
  4) hire_date / DATE / not null
3. instructor 테이블에 다음 정보 추가
  - 이일 / 21@test.com / 2025-09-18
  - 이일 / 22@test.com / 2022-09-18
  - 이일 / 23@test.com / 2023-09-18

```sql
CREATE TABLE instructor(instructor_id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, email VARCHAR(100) NOT NULL, hire_date DATE NOT NULL);

INSERT INTO instructor (name, email, hire_date) VALUES ('이일', '21@test.com', '2025-09-18'), ('이이', '22@test.com', '2022-09-18'), ('이삼', '23@test.com', '2023-09-18');
```
과목 테이블 courses를 생성
courses_id / INT / primary key
course_name / varchar(100)
instructor_id / int / Foregin key
start_date / DATE
end__date / DATE

```sql
CREATE TABLE courses(course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(100) NOT NULL, instructor_id INT NOT NULL, start_date DATE NOT NULL, end_date DATE NOT NULL, FOREIGN KEY (instructor_id) REFERENCES instructor(instructor_id));
```

students / instructor간의 관계 테이블 생성
테이블명 : student_courses

student_id / INT / PK,FK
course_id / INT / PK,FK

- student_id와 course_id의 값을 조합해 복합 기본 키(Composite Primary Key)로 설정
- 일반 PK처럼 각 행이 고유하게 보장하고 같은 수강생이 동일한 과목을 중복해서 등록 불가능하게끔
- 예를 들어 student_id가 1인 학생이 course_id = 2에 해당하는 python 과목을 수강하면 student_course의 pk는 12인데 추후 1이 다시 2를 들음녀 12로 중복되서 수강 불가

출석 현황 테이블 생성(attendence)
테이블명 : attendence
attendence_id / int / pk
student_id / int / fk
course_id / int / fk
date / DATE
status / varchar(10) / 예시 출석, 결석 etc
```sql
CREATE TABLE attendencekor_it (attendence_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT NOT NULL, DATE DATE NOT NULL, STATUS VARCHAR(10) NOT NULL, FOREIGN KEY(student_id) REFERENCES students(students_id), FOREIGN KEY(course_id) REFERENCES courses(course_id));
```

- attendence
```sql
INSERT INTO attendence (student_id, course_id, DATE, STATUS) VALUES (1, 1, '2025-09-18', '출'), (2, 1, '2025-09-18', '결'), (4, 1, '2025-09-18', '출'), (1, 2, '2025-09-19', '출'), (2, 2, '2025-09-19', '출'), (4, 2, '2025-09-19', '결');
```

- courses
```sql
INSERT INTO courses (course_name, instructor_id, start_date, end_date) VALUES ('JAVA', 1, '2025-09-01', '2025-09-30'),('Python', 2, '2025-09-02','2025-09-29');
```

- instructor
```sql
# INSERT INTO instructor(name, email, hire_date) VALUES ('김선생', 'kim@test.com', '2025-07-01'), ('이선생', 'lee@test.com', '2025-07-01');
```

- student_courses
```sql
INSERT INTO student_courses(students_id, course_id) VALUES (1,1), (2,1), (4,1), (1,2), (4,2);
```

지시 사항:
1. 수강생 목록 및 과목 조회 : students / students_course / courses 테이블을 결합해 각 학생의 이름과 학생이 수강하는 모든 과목을 조회. 결과는 이름 순서대로
```sql
SELECT s.students_name, c.course_name FROM students s INNER JOIN student_courses sc ON s.students_id = sc.students_id INNER JOIN courses c ON sc.course_id = c.course_id ORDER BY s.students_name;
```

2. 김사백오십 학생의 이름과 이메일 수강과목 출력
```sql
SELECT s.students_name, s.students_email, c.course_name FROM students s INNER JOIN student_courses sc ON s.students_id = sc.students_id INNER JOIN courses c ON sc.course_id = c.course_id WHERE s.students_name = '김사백오십';
```

3. 이일 강사의 교수 과목과 수강생을 출력
```sql
SELECT i.name, c.course_name, COUNT(DISTINCT sc.students_id) AS sCnt FROM instructor i INNER JOIN courses c ON i.instructor_id = c.instructor_id INNER JOIN student_courses sc ON c.course_id = sc.course_id WHERE i.name = '이일';
```
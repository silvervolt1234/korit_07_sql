# MariaDB 설치과정(windows version)
chrome -> mariadb 검색
https://mariadb.org/
download 탭 -> default 설정으로 download

tcp port : 3310
id : root
pwd : 1234

mariaDB만 설정을 했는데 window + heidiSQL

# 새 DB 생성 방법
Unnamed -> 새로 생성 -> 새 데이터베이스
Database name : play_sql


# 과정 정리(사전 준비 단계)
1. MariaDB 설치
2. MariaDB에 default DBMS 프로그램인 HediSQL 설치
3. database 생성 -> play_sql
4. play_sql 내부에 csv 파일 가져오기
  - 이미 만들어진 데이터 가져온 부분
  - products.csv 로드에 문제 발생

# RDBMS
RDBMS(관계형 데이터베이스 관리 시스템 : Relational DataBase Management System)는 데이터를 관계형 모델을 기반으로 정리, 관리, 조작하는 소프트웨어 시스템. 관계형 모델은 데이터를 테이블(릴레이션) 형식으로 표현하며 각 테이블은 행(row), 열(column)으로 구성. 데이터 무결성 / 일관성 / 보안 등을 유지하며 효율적 관리 접근 보조

## 주요 특징
1. 테이블 기반 구조 :
  - 각 데이터는 행(record)과 열(field)로 구성된 테이블에 저장
  - 각 테이블은 고유의 이름을 가지며 데이터베이스 내에서 다른 테이블과 관계 맺기 가능
2. SQL 사용 :
  - RDBMS는 데이터를 정의하고 조작하기 위해 SQL(Structured Query Language)을 사용
  - SQL은 데이터베이스 생성 / 테이블 생성 / 데이터 삽입 / 수정 / 삭제 / 조회 등의 조작을 위한 표준 언어(DBMS에 따라 dialect 존재)
3. 데이터 무결성 :
  - 데이터의 정확성과 일관성을 유지하기 위해 무결성 제약 조건(Primary Key, Foreign Key, Unique, Check 등)을 지원. 특히 PK / FK 개념에 집중
  - 트랜잭션 처리(ACID 특성 : Atomicity / Consistency / Isolation / Durability) 를 통해 데이터 무결성 보장
4. 관계 설정 :
  - 테이블간의 관계를 설정해 데이터의 중복을 최소화하고 데이터의 참조 무결성을 유지
  - 관계의 유형으로 일대일(1:1) / 일대다(1:N) / 다대다(N:N)
5. 데이터 보안 :
  - 사용자 권한 관리 / 데이터 암호화 등을 통해 데이터베이스 보안 강화
  - 각 사용자는 데이터베이스 / 테이블 / column 단위로 접근 권한 설정

## RDBMS의 주요 기능 요약
- 데이터 정의 : 테이블 / 뷰 / 인데스 / 스키마 등을 생성하고 관리
- 데이터 조작 : 데이터 삽입 / 수정 / 삭제 / 조회 등을 수행
- 데이터 제어 : 트랜잭션 관리 / 동시성 제어 / 회복 기능 제공
- 데이터 보안 : 사용자 권한 설정 / 데이터 암호화 / 감사 로그 등 지원

# SQL 학습
## 정의
- 구조화된 질문 언어 : RDMS를 관리하기 위해 고안된 프로그래밍 언어
### SQL의 실행 방식
- 컴퓨터에게 특정 데이터 정보를 가지고 오라고 명령할 때 필요한 정보 :
  1. 무엇을 가지고 와야 하나
  2. 어디에서 가지고 와야 하나
- 이상의 최소한의 정보들을 포함해 컴퓨터가 알아들을 수 있고 또 사람이 알아볼 수 있는 형태로 구현한게 SQL

```sql
SELECT * FROM users;
데이터를 가져오라(SELECT) 전부(*) user라는 테이블에서(FROM users) 종료(;)
```
그리고 SQL문 실행을 `쿼리문을 실행했다`, `쿼리문을 날렸다` 등의 표현 사용. SQL을 컴퓨터에 전달했다는 의미

Springboot 상황에서 Query Method로 SQL과는 다르지만 Java에서 method 형태로 명령어를 정의하고 호출시 MariaDB로 접속해 특정 데이터를 가져오게 제어

## SQL 종류
1. DML(Data Manipulation Language) : 데이터 조작 언어라는 의미로 데이터베이스 내부 데이터를 관리하기 위한 기능. 주로 데이터를 조회(Read)/추가(Insert)/수정(Update)/삭제(Delete) 등의 기능을 수행하기 위해 사용
- 그리고 이상의 기능을 CRUD로 표현
- C : Create
- R : Read
- U : Update
- D : Delete

2. DDL(Data Definition Language) : 데이터 정의 언어라는 뜻으로 관계형 데이터베이스 내의 저장 단위인 테이블(table)과 컬럼(column)을 정의하고 관리하는 명령어를 포함. 저장 공간을 생성/수정/삭제 등의 주로 데이터 저장 공간 결정 기능이며 주요 명령어는
- CREATE
- DROP
- TRUNCATE 등

3. DCL(Data Control Language) : 관리 목적으로 주로 사용되며 데이터베이스에 접근하려는 사용자의 권한을 관리하거나 보안 기능 담당. 주요 명령어는 GRANT / REVOKE 등

4. TCL(Transaction Control Language) : 트랜잭션 제어 언어하는 의미로 데이터베이스를 조작하는 명령 단위인 트랜잭션을 관리할 때 사용하는 기능(EX: 은행을 경유해 A고객에게서 B고객으로 이체하는 과정). 주요 명령어 : COMMIT / ROLLBACK

# 주요 용어
1. 테이블(table) :
  - 관계형 데이터베이스 내에서 행과 열로 구성된 데이터를 저장하는 기본 단위.
  - 엑셀을 하나의 데이터베이스라 하면 테이블은 엑셀 내의 sheet
  - 각 테이블은 고유한 식별자인 기본 키(Primary Key)를 보유
  - 기본 키는 테이블 내에서 각 행을 고유하게 식별하기 위해 사용
  - 테이블간의 관계를 맺을 때는 외래 키(Foregin Key)를 사용

2. 컬럼(column) :
  - 테이블에서 하나의 속성(attribute / Java에서는 field)에 해당하는 데이터를 저장하는 공간으로 세로 줄인 열에 해당
  - 각 컬럼에는 컬럼명 / 데이터 타입 / 크기 / 제약 조건 등 정의
  - Java는 String studentName;이라호 한다면 데이터 타입과 컬럼 명을 설정한 케이스

3. 행(Row) :
  - 테이블에서 가로줄 하나 의미(=Record)
  - 테이블에서 하나의 개별 데이터 단위를 나타내며 특정 데이터가 저장되고 조회될 때 행 단위로 처리(Java는 객체)

4. 기본 키(Primary Key / PK)
  - 기본 키는 테이블에서 각 행(객체)을 고유하게 식별할 수 있는 값(html 태그의 id처럼 중복 불가능)
  - 기본 키는 하나가 아닌 여러 값의 조합으로 이루어질 수 있으며 이러한 기본 키는 테이블 내에서 중복되지 않는 유일한 값

5. 외래 키(Foregin Key / FK) :
  - 외래 키는 다른 테이블의 `기본 키`와 매칭되어 해당 테이블과의 관계 정의
  - 다른 테이블의 기본 키 값을 가져와 컬럼을 구성하며 이후 테이블끼리의 결합(Join 연산)에 사용
  - 일반적으로 다른 테이블의 기본 키와 같은 데이터 타입과 크기(int / long) 보유

# products 테이블에 값 집어넣기 예시
```sql
INSERT INTO products (id, name, price, discount_price) VALUES
(1, 'Terrarossa', 18, 18),
(2, 'Mini Chee', 19, 19),
(3, 'Beanboth', 10, 10),
(4, 'Starbucks P', 21, 21),
(5, 'Organic P', 21.5, 21.5),
(6, 'Grandma Z', 29, 29),
(7, 'Uncle Bob', 30, 30),
(8, 'Northwood', 40, 40),
(9, 'Mishi Keb', 32, 32),
(10, 'Nike Men''', 31, 31),
(11, 'Newbalan', 21.5, 21.5),
(12, 'Quego Ma', 38, 38),
(13, 'Konbu Tea', 6, 6),
(14, 'Guilong G', 23.23, 23.23),
(15, 'Senen Sh', 15.5, 10.5),
(16, 'Robio Cho', 17.45, 17),
(17, 'Alite Mul', 39, 39),
(18, 'Carnarvon', 62.5, 62.5),
(19, 'Feather G', 52, 52),
(20, 'Sir Rodney', 81, 70),
(21, 'Air Iche', 10, 10),
(22, 'Air Iche', 21, 15),
(23, 'Bicycle Pa', 9, 7),
(24, 'Snono Sp', 49.99, 39.99),
(25, 'Doon Pour', 23.85, 23.85),
(26, 'JBL FLIP 5', 109, 109),
(27, 'Shinogi S', 43.9, 43.9),
(28, 'ABRAMTE', 99, 89),
(29, 'Boosiey H', 123.79, 89),
(30, 'Nord-Osb', 25.89, 25.89),
(31, 'Gorgonzo', 12.5, 12.5),
(32, 'Macar Poin', 55, 55),
(33, 'Geitost', 2.5, 2.5),
(34, 'Sasquatch', 14, 14),
(35, 'Steepbe H', 18, 18),
(36, 'Inlagd Sill', 19, 19),
(37, 'Graved lox', 20, 20),
(38, 'Thiswork', 263.81, 263.81),
(39, 'Chartreuse', 18, 18),
(40, 'Brocken B', 18.5, 18.5),
(41, 'Jack''s New', 9.65, 9.65),
(42, 'Singapor', 14, 14),
(43, 'Ipora Coffe', 46, 46),
(44, 'Guia Malal', 19.45, 19.45),
(45, 'THE ORGA', 11, 9.5),
(46, 'Spegelsild', 12, 12),
(47, 'Zaanser K', 9.5, 9.5),
(48, 'Chocolad', 12.75, 12.75),
(49, 'Maxillaku', 20, 20),
(50, 'Valkoinen', 16.25, 16.25),
(51, 'Manjimus', 5.3, 5.3),
(52, 'Pilo Mix', 7, 7),
(53, 'North-West', 32.5, 32.5),
(54, 'OLD BAY', 36, 33),
(55, 'India Tree', 9.95, 9),
(56, 'Soncolli d', 38, 38),
(57, 'Ravioli an', 19.5, 19.5),
(58, 'Escargots', 13.25, 13.25),
(59, 'Raclette C', 55, 55),
(60, 'Canembe', 34, 34),
(61, 'Planters P', 22, 16),
(62, 'Tarte au s', 49.3, 49.3),
(63, 'Veggie-sp', 33.9, 33.9),
(64, 'Corn Smitt', 33.25, 33.25),
(65, 'Louisiana', 21.05, 21.05),
(66, 'Louisiana', 17, 17),
(67, 'Laughing', 14, 14),
(68, 'Scottish L', 12.5, 10.5),
(69, 'Outbound', 38, 32),
(70, 'Outback L', 15, 15),
(71, 'Nutta Sa', 21.4, 21.4),
(72, 'Mozzarella', 34.8, 34.8),
(73, 'Burbaber', 15, 13.99),
(74, 'Elkessan Of', 10, 10),
(75, 'SANSUNG', 499.99, 349.99),
(76, 'Massaged l', 39.9, 39.9),
(77, 'Womens Li', 37.99, 37.99);
```

# SQL 문의 예시 포함
1. DDL
  - CREATE / ALTER / DROP
  - CLI에서는 테이블을 ㅂ명령어로 처리
```sql
  CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,    컬럼 # 1
    username VARCHAR(50) NOT NULL,        컬럼 # 2
    email VARCHAR(100) NOT NULL           컬럼 # 3
  );
```
Java로 표현하면
```java
public class User {
  @NonNull
  private int id;
  @NonNull
  private Stirng username;
  @NonNull
  private String email;
}
```

2. DML
  - 주요 명령어 : INSERT / SELECT / DELETE / UPDATE
  - 예시
```sql
INSERT INTO users(username, email) VALUES ('홍길동', 'honggildong@test.com');
insert into 테이블명 (컬럼명1, 컬럼명2, ... ) values(컬럼명1의 값, 컬럼명2의 값, ...);

SELECT * FROM users;
select 컬럼명1, 컬럼명2, FROM 테이블명;

UPDATE users SET email = 'new_email@example.com' WHERE id = 1;
update 테이블명 SET 고치려는컬럼명 = '고치려는컬럼명의값' WHERE 조건식;

DELETE FROM useres WHERE id = 1;
delete from 테이블명 WHERE 조건식;
```

# 원하는 데이터를 가져오고 필터링하기
## 데이터 처리 4 요소 : 생성 / 조회 / 수정 / 삭제

### SELECT
1. 사전에 미리 데이터들이 있다고 가정할시 가장 중요한 부분으로서 어떤 데이터를 어디에서 가지고 올까와 관련된 구문

```sql
SELECT 'Hello SQL!';
```
이상의 결과값은 테이블 명이 없고 Hello SQL이라는 컬럼에 Hello SQL! row가 생성된걸 확인 가능. 그래서 select는 `~를 출력`의 의미
```sql
select 12 + 7;
```
현재 특정 테이블과 관계 없는 상황에서 string 값을 사용하거나 혹은 연산 가능

기본 예제:
결과 창의 첫 행에 Find / Insight / with SQL을 3칸에 걸쳐 순서대로 출력. 컬럼명과 row를 각각 순서대로 Find / Insight / with SQL 나오게 할 것
```sql
SELECT 'Find', 'Insight', 'with SQL';
```
- 다수의 row 데이터를 순서대로 집어넣기 위해서는 ','를 통해서 연결
```sql
SELECT 
	'Find' AS 'First',
	'Insight' AS 'Seceond', 
	'with SQL' AS 'Third';
```
의 방식으로 row에 대한 column 명 지정 가능

연습 문제

1. SELECT를 이용해 28 + 891 계산
2. SELECT를 이용해 19 X 27 계산. 단, 컬럼명은 Result
3. SELECT를 이용해 다음 세가지 결과글 각각 다른 컬럼으로 결과창에 출력
  - 37 + 172(컬럼명 : PLUS)
  - 25 X 78 (컬럼명 : TIMES)
  - I love SQL! (컬럼명 : Result)
```sql
SELECT 28 + 891;
SELECT 19 * 27 AS 'Reuslt';
SELECT
	37 + 172 AS 'PLUS',
	25 * 78 AS 'Times',
	'I love SQL!' AS 'Reuslt';
```
이상의 경우 String 데이터(MariaDB 기준 VARCHAR의 경우) 큰따옴표/작은따옴표 구분 없음. 하지만 컬럼명을 지정할 때는 없어도 될때 존재

### FROM
- 데이터가 저장된 위치를 알려주는 전치사
```sql
SELECT * FROM users;
```
\* : 와일드 카드라고도 하며 애스터리스크(asterisk)라고도 하는데 여기서는 모든 컬럼을 나타내는 표현
```sql
SELECT * 
  FROM products;
```
으로 작성해도 결과값은 차이 없음. 이상에도 알 수 있는것은 html 태그와 마찬가지로 개행을 하는 것을 컴퓨터가 신경 x

단 실무 개발자들은 적절한 개행을 이용해 가독성 있는 SQL 작성 원칙

제품 정보 테이블 products에서 첫 3개의 행의 데이터만을 가지고 오는 SQL
```sql
SELECT *
  FROM products
  LIMIT 3
```
기존의 코드는 전체 테이블의 ALL rows를 불러왔고 full scan이라고 표현. 하지만 데이터의 양이 너무 많으면 그 데이터들을 불러오는데 너무 많은 리소스가 들기에 작업이 원할하지 않을 수 있어 full scan 자체는 지양되는 편. 그래서 단순히 데이터의 상태를 파악하려면 LIMIT를 추가해 일부 데이터만 확인하는 습관 들이기
* MariaDB에서는 LIMIT를 쓰지만 Oracle / MySQL은 TOP 명령어 사용

연습 문제
products 테이블에서 id, name 컬럼의 데이터들 상위 30개만 추출
```sql
SELECT id, name
  FROM products
  LIMIT 30;
```

1. orderdetails 테이블의 전체 컬럼을 표시
```sql
SELECT * from orderdetails;
```
2. users에서 상위 7건의 데이터만 표시
```sql
SELECT * from users LIMIT 7;
```
3. orders에서 주문 아이디 / 회원 아이디  주문 일자 컬럼의 모든 데이터 표시
```sql
SELECT id, user_id, order_date FROM orders;
```

### WHERE
- SELECT / FROM을 통해 출력할 컬럼을 결정하고 LIMIT으로 일정량의 데이터들을 뽑았는데
- 이상의 통제가 특정 조건을 만족 시키는 row를 출력한다고는 할 수 없다
- 특정 컬럼의 A 값만 출력 하거나 여성회원 정보만 가지고 오거나 마케팅 수신 동의를 한 사람들만 뽑아서 문자를 보내는 등의 족선을 만족시키는 데이터만 조회 역시 매우 중요
- SELECXT에서는 테이블의 세로 부분인 컬럼을 제어했다면(어떤 컬럼을 보여줄 지) WHERE는 가로인 row를 컨트롤

회원 정보 테이블 users에서 거주 국가(country)가 한국(Korea)면서 동시에 마케팅 수신 동의(is_marketing_agree)를 동의(1)한 데이터를 추출하는 쿼리문
```sql
SELECT *
	FROM users
	WHERE 
		country = 'Korea'
		and
		is_marketing_agree = 1;
```
이런 경우 회원 정보 테이블 users에서 거주 국가(country)가 한국(Korea)가 아닌 데이터를 추출하는 쿼리문

```sql
SELECT * from users WHERE country != 'Korea';
```

회원 정보 테이블에서 거주국가가 한국이면서 id가 10인 회원만 추출(결과값은 1 혹은 0개)
```sql
SELECT * from users WHERE country = 'Korea' AND id = 10;
```

회원 정보 테이블 users에서 가입 일시(created_at)가 2010-12-01부터 2011-01-01까지인 회원 정보 출력
```sql
SELECT * FROM users WHERE created_at BETWEEN '2010-12-01' AND '2011-01-01';
```
이상의 SQL문에서 created_at의 자료형이 DATE가 아닌 VARCHAR이었는데 프로그램에 따라 BETWEEN이 적용 되지 않을 수도 있음

BETWEE A AND B : A와 B 사이
<br>A - 시작 날짜
<br>B - 종료 날짜

```sql
SELECT * FROM users WHERE created_at >= '2010-12-01';
```

연습문제: 회원 정보 테이블 users에서 가입일시가 2010-12-01부터 2011-01-01까지인 회원 정보를 BETWEEN 없이 출력
```sql
SELECT * FROM users WHERE created_at >= '2010-12-01' AND created_at <= '2011-03-01';
```

연습문제 : 회원 정보 테이블 users에서 거주 국가(country)가 Korea거나 UK 혹은 USA인 회원 정보만 출력
```sql
SELECT * FROM users WHERE country = 'Korea' OR country = 'USA' OR country = 'UK'; 
```

위의 SQL문을 IN 전치사를 적용하면 
```sql
SELECT * FROM users WHERE country IN ('Korea', 'USA', 'UK')
```
python에서도 for / if 문을 쓸 때 확인됬지만 IN의 의미는 'IN 다음에 나오는 interavble 내에 있는' 이라는 의미

그렇기에 WHERE은 실질적 IF문

회원 정보 테이블 users에서 거주 국가(country)가 Korea거나 UK 혹은 USA가 아닌 회원 정보만 추출 하기
```sql
SELECT * FROM users WHERE country NOT IN ('Korea', 'USA', 'UK')
```
그렇기에 python과 마찬가지로 not 연산자와 ! 둘 다 존재

NOT IN : ~ 중에 있지 않은

예제 문제: users에서 country 이름이 _S로 시작하는_ 회원 정보 추출
```sql
SELECT * FROM users WHERE country LIKE 'S%';
```

이상의 SQL문의 중요점은 게시판 등지에서 filtering을 하는 경우가 있는데 특정 키워드를 찾으려면 
```sql
SELECT * FROM articles WHERE title LIKE '%검색어%';
```

제목 + 내용에도 쿼리 여부 확인
```sql
SELECT * FROM articles WHERE title LIKE '%쿼리%' OR content LIKE '%쿼리%';
```

- `LIKE` :
  - 기존에 사용한 = 과 != 연산자는 컬럼값이 조건 값과 정확히 일치하는 것만 가져올 수 있는 반면 LIKE는 WHERE에서 조건문을 작성할 때 일부 패턴에 일치하는 데이터 역시 가져 올 수 있다
  - LIKE 뒤의 ' '/" " 내에서는 와일드카드를 사용 가능한데 LIKE가 오면 와일드 카드의 위치
  - 와일드 카드 `%`는 0 개 이상의 임의의 문자열을 의미하는 메타 문자로 사용되는데 `S%`의 의미는 첫 글자가 S인데 뒤 몇개의 문자가 올지는 모르나 S뒤에 여러개의 문자가 나열된 결과값을 전부 가져온다고 해석

  - `-` : 한 개의 임의의 문자
  - `[ ]` : 대괄호 내의 문자 집합 중 일치하는 1개의 문자

회원 정보 테이블 users에서 거주 국가 이름이 S로 시작하지 않는 회원 정보 추출
```sql
SELECT * FROM users WHERE country NOT LIKE 'S%';
```

- WHERE은 조건을 만족하는 데이터만 가져오게 제한(row 기준이라는 측면에서 select와 차이 존재)
- FROM이 끝난 뒤에 위치
- WHERE을 사용해 필터링하면 조건에 맞는 row만 선태고디어 출력. 즉 가로축에 해당하는 행 단위로 필터링이 적용되면 WHERE를 통해 조건을 지정하면 해당 조건에 부합하는 행만 출력(Springboot와 연결되면 부합하는 객체만 출력)
- WHERE 컬럼명 연산자 조건값의 순서로 구성 `WHERE country = 'Korea'`와 같은 형식
- 한 가지 이상의 개수 제한 없이 동시에 사용 가능하며 개별 조건을 연결할때는 논리 연산자인 AND / OR 사용

## 연습 문제
1. 회원 정보 테이블에서 거주 국가가 멕시코인 회원의 가입일시, 연락처, 거주 도시, 거주 국가 정보 출력
```sql
SELECT created_at, phone, city, country FROM users WHERE country = 'Mexico';
```

2. 제품 정보 테이블 orders에서 제품 아이디가 20 이하고 정상 가격(price)는 30 이상인 정보 추출. 단 정상 가격에서 얼마나 할인됬는가를(price - discount price)를 discount_amount로 추가
```sql
SELECT *, price - discount_price AS discount_amount FROM products WHERE id <= 20 AND price >= 30;
```

3. users에서 거주 국가가 한국도, 캐나다도, 벨기에(Belgium)도 아닌 회원의 정보를 모두 추출(or 사용 금지)
```sql
SELECT * FROM users WHERE country NOT IN ('Korea', 'Canada', 'Belgium')
```

4. products에서 제품명이 N으로 시작하는 제품의 정보를 id / name / price 컬럼만 추출
```sql
SELECT id, name, price FROM products WHERE name LIKE 'N%';
```

5. 주문 정보 테이블 orders에서 주문 일자가 2015-07-01 에서 2015-10-31 까지가 아닌 정보만 추출
```sql
SELECT * FROM orders WHERE order_date NOT BETWEEN '2015-07-01' AND '2015-10-31';
```

## ORDER BY
- 특정 컬럼을 기준으로 오름차순(ASC) / 내림차순(DESC)으로 할 것인지 결정 여부
```sql
SELECT * FROM users ORDER BY id ASC;
```
이상의 SQL문 해석은 users 테이블의 전체 컬럼을 다 가지고 오는데 그 중 id 컬럼을 기준으로 오름차순해 출력

- GUI 형태로 HediSQL을 쓸 경우 일일히 SQL문을 쓸 필요 없이 마우스 설정으로 오름차순이 가능
```sql
SELECT * FROM users ORDER BY city DESC;
```
거주 도시 기준으로 내림차순 정렬
- 참고 : 아스키 코드 기준으로 오름차순 / 내림차순 정렬

연습문제
users에서 가입일시 기준 오름차순 정렬해 전체 컬럼 출력
```sql
SELECT * FROM users ORDER BY created_at ASC;
```

users에서 가입일시 기준 내림차순 정렬해 전체 컬럼 출력```sql
```sql
SELECT * FROM users ORDER BY created_at DESC;
```

- ORDER BY는 컬럼명을 몰라도 정렬 수행이 가능. 예를 들어 전체 테이블의 첫 번째 컬럼은 보통 고유 식별자인 id인데 테이블에 따라서 order_id거나 그냥 id도 있는 등 상황에 따라 다르게 작성
```sql
SELECT * FROM users ORDER BY 1 ASC;
```
식으로 첫 테이블만 지정 가능

연습 문제 :
users에서 username / phone / city / id 컬럼을 순서대로 출력하되 결과를 첫 번째 컬럼 기준으로 오름차순 정렬
```sql
SELECT username, phone, city, country, id FROM users ORDER BY 1 ASC;
```
이상의 SQL문을 기준으로 id를 기준이 아니라 username을 기준으로 오름차순이 적용되었음을 확인 할 수 있는데 이를 통해 컬럼의 순서가 데이터의 추출에 영향이 있는걸 알 수 있다

그래서 개발자들은 보통 ORDER BY 다음에 숫자 쓰기를 지양

users에서 city / id만 출력하되 거주도시 기준으로는 내림차순, 회원 아이디 기준 오름차순에서 출력
```sql
SELECT city, id FROM users ORDER BY city DESC, id ASC;
```
ORDER BY 뒤에 복수의 정렬조건이 나열되면 `,`를 기준으로 작성. 그러면 출력 결과를 보기 전 해석하기로는 city 컬럼 먼저, id 컬럼이 뒤에 나오는데 city를 기준으로 내림차순을 먼저하고 같은 도시들이 중복될 시 id 기준 오름차순

## 연습 문제:
1. 제품 정보 테이블에서 정상 가격이 비싼 제품부터 순서대로 모든 컬럼 출력
```sql
SELECT * FROM products ORDER BY price DESC;
```

2. 주문 정보 테이블에서 주문 일자 기준으로 최신순 정렬해 모든 컬럼 출력
```sql
SELECT * FROM orders ORDER BY order_date DESC;
```

3. 주문 상세 정보 테이블 orderdetails에서 제품 아이디(product_id) 기준으로 내림차순 정렬하고 같은 제품 아이디 내에서는 판매 수량(quantity) 값을 기준으로 오름차순 정렬해 모든 컬럼 출력
```sql
SELECT * FROM orderdetails ORDER BY product_id DESC, quantity ASC;
```

# SQL실무 예시
SELECT / FROM / WHERE / ORDER BY

- 배달 서비스에서 어떻게 추출하는가?
1. 2023-08-01에 주문한 내역 중 쿠폰 할인이 적용된 내역만 추출
```sql
SELECT * FROM 주문정보 WHERE 주문일자 = '2023-08-01' AND 할인금액 > 0;
```

2. 마포구에서 1인분 배달이 가능한 음식점만 추출
```sql
SELECT * FROM 음식점정보 WHERE 지역 = '마포구' AND 1인가능여부 = 1;
```
0과 1은 boolean 자료형
참조 사항 : 오늘 일자를 가져오는 부분에서 특정 일자에서 특정 일자에서 달을 차감하는 함수가 DB별로 다르다

- 전자책 서비스에서의 적용 사례
1. 출간된지 한 달 이내의 신간 중 페이지가 200 이상인 도서만 추출
```sql
SELECT * FROM 출간일자 >= (오늘일자 - 한 달) AND 페이지 >= 200;
```

2. 최근 한 달 이내에 도서 구독 멤버십에 가입한 회원 수 추출
```sql
SELECT * FROM 회원정보 WHERE 가입일자 >= (오늘일자 - 한 달) AND 멤버십가입여부 - 1
```